{"pages":[],"posts":[{"title":"From Heap Sort to Priority Queue 2","text":"From the previous post, I have discussed the principle and code of the Heap Sorting. Using the heap, we can develop a general data structure, such as Priority Queue. bash123456789101112public class PriorityQueue&lt;E&gt; extends AbstractQueue&lt;E&gt; implements java.io.Serializable { private static final long serialVersionUID = -7720805057305804111L; //the size of heap by default private static final int DEFAULT_INITIAL_CAPACITY = 11; //a container for keeping heap data transient Object[] queue; //the number of the elements in the heap private int size = 0; private final Comparator&lt;? super E&gt; comparator; In the PriorityQueue constructor, a method heapify will be called to initialize the heap, as follows: bash12345678910 private void heapify() { for (int i = (size &gt;&gt;&gt; 1) - 1; i &gt;= 0; i--) siftDown(i, (E) queue[i]); }private void siftDown(int k, E x) { if (comparator != null) siftDownUsingComparator(k, x); else siftDownComparable(k, x); } For the specific code, please refer to my previous post. we will focus on same important methods. bash123456789101112 public E poll() { if (size == 0) return null; int s = --size; modCount++; E result = (E) queue[0]; E x = (E) queue[s]; queue[s] = null; if (s != 0) siftDown(0, x); return result;} We can see from the poll method that it takes the 0-th element directly, and then continue to adjust the remaining elements to a min-heap. bash1234567891011121314public boolean offer(E e) { if (e == null) throw new NullPointerException(); modCount++; int i = size; if (i &gt;= queue.length) grow(i + 1); size = i + 1; if (i == 0) queue[0] = e; else siftUp(i, e); return true; } It is the same story for inserting a elements from the methods offer shows above. So we can get that for the methods poll and offer in Priority Queue, the time complicity are both logN.","link":"/2021/02/19/3-PQ/"},{"title":"How to create your own hexo blog -- (learning note)","text":"This is a tutorial for those who what to create their own Blog using Hexo based on Mac OS from scratch.There are 4 parts including installing, creating hexo config, deploying to remote, and changing themes.Without further do, let’s start!!! Quick StartInstalling Before installing Hexo, we should install Node.js first. To check whether you have installed Node.js properly, open Terminal and input following code. 1$ node -v You need to check npm also. 1$ npm -v Install Hexo config. 1$ npm install -g hexo-cli Then checking whether hexo was installed properly. 1$ hexo -v Until now, we have finished the first step: installing. Creating blog config Build a blog folder. Note: you can delete the folder directly if you don’t want the blog any more. 1$ mkdir blog Initialize 123$ cd blog$ hexo init$ hexo s Until now, the hexo config has done, we can open the local address to go through it. now, let’s start a new post. 1$ hexo n 'my first blog' you can edit the post using Visual Studio Code under the folder ‘source’ of blog, or using vim under terminal as follows. 1$ vim my-first-blog.md Deploying to Remote Deploy to github: create a new repository on github. NOTE: the name of the ropos must be same with your username Installing a config under the blog folder.1$ npm install --save hexo-deplyer-git Setup ‘_config.yml’ file.12$ vim _config.yml$ i Scrolling to the bottom to find ‘deployment’, and add 3 lines as following: type: gitrepo: ’TheNewCreatedGitRepo’branch: master ***Note: there should keep one space after : ***Then, press ’esc’ and input :wq for save and quit vim. Deploy to remote that is github.1$ hexo d Changing the theme Download the theme from github, or search online and install it as their instructions.1$ git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia Application the theme12$ vim _config.yml$ i modify ‘landscape’ to ‘yilia’ at the theme of ‘extensions‘ Generate, start, and deploy it.1234$ hexo clean$ hexo g$ hexo s$ hexo d Finally, a personal blog website was done. I will go further into the themes configuring, including Logo, paging, navigation bar and so on. Reference: (https://www.youtube.com/watch?v=erKYtw4Rfhk&amp;t=790s)","link":"/2021/01/22/hello-world/"},{"title":"Introduction of Meshgrid function of Numpy","text":"Recently, I have seen the use of meshgrid in several places. I always feel not impressed, although I have accessed it before.Therefore, this node will discuss in detail about the usage of meshgrid in Numpy. Bacic Usage of Meshgrid FunctionBy the definition, the meshgrid function is to draw a grid based on two group of coordinates. For example: [X, Y] = meshgrid(x, y)We can also write like this: [X, Y] = meshgrid(x) which is equivalent to [X, Y] = meshgrid(x, x) Similarly, [X, Y, Z] = meshgrid(x, y, Z)generates a three-dimensional array, which can be used to calculate functions of three variables and draw three-dimensional diagrams. Here, we mainly take [X, Y] = meshgrid(x, y) as an example to introduce the function. [X, Y] = meshgrid(x, y) converts the area defined by vectors x and y into matrices X and Y, where the row vector of matrix X is a simple copy of vector x, and the column vector of matrix Y is vector y Simple copy (Note: X and Y in the code below are both arrays, which are collectively referred to as matrices in the text). Assuming that x is a vector of length m and y is a vector of length n, the dimensions of the final matrix X and Y are both nm (note that it is not mn). Let’s demonstrate through the code below: Generate vector x and ybash12345678910import numpy as npimport matplotlib.pyplot as plt%matplotlib inlinem, n = (5, 3)x = np.linspace(0, 1, m)y = np.linspace(0, 1, n)X, Y = np.meshgrid(x,y) View vector x and ybash12345678910xout:array([ 0. , 0.25, 0.5 , 0.75, 1. ])yout:array([ 0. , 0.5, 1. ]) View matrix X and Ybash1234567891011121314Xout:array([[ 0. , 0.25, 0.5 , 0.75, 1. ], [ 0. , 0.25, 0.5 , 0.75, 1. ], [ 0. , 0.25, 0.5 , 0.75, 1. ]])Yout:array([[ 0. , 0. , 0. , 0. , 0. ], [ 0.5, 0.5, 0.5, 0.5, 0.5], [ 1. , 1. , 1. , 1. , 1. ]]) Demo the dimensions of the matrixbash123456789X.shapeout:(3, 5)Y.shapeout:(3, 5) Visualizing the result in matplotlibbash12plt.plot(X, Y, marker='.', color='blue', linestyle='none')plt.show() result Finally, we can also get the data of coordinates as follows:bush12345678910111213141516171819z = [i for i in zip(X.flat,Y.flat)]zout:[(0.0, 0.0), (0.25, 0.0), (0.5, 0.0), (0.75, 0.0), (1.0, 0.0), (0.0, 0.5), (0.25, 0.5), (0.5, 0.5), (0.75, 0.5), (1.0, 0.5), (0.0, 1.0), (0.25, 1.0), (0.5, 1.0), (0.75, 1.0), (1.0, 1.0)]","link":"/2021/03/02/4_meshgrid/"},{"title":"From Heap Sort to Priority Queue 1","text":"Generally, Heap sort is used to solve the K-th largest number problems.The definition of a heap is as follows: Heap is a complete binary tree. For all nodes, if it is not null, if there is a left child node and the left child is larger than it. Meanwhile, if it have a right child node and the right child node is larger than it. Then, this is a min-heap, or a max-heap vice versa. For each node i, parent(i) = floor(i - 1)/2, leftChild(i) = 2i + 1, rightChild(i) = 2i + 2. When initializing the heap, which node should we start is the most important thing. We will start from the very last non-leaf node, and the index of the node is (len - 1)/2, the ‘len’ means the length of the array. The implementation code as following, assuming we initiate a max heap. bash12345678910111213141516171819202122232425262728//at first，the index is (len-1 - 1)/2，that is the last non-leaf node private void heapSortOfIndexNode(int[] arr,int index,int length){ //find out left child int leftC = 2*index+1; //find out right child int rightC = leftC +1; int maxIndex = index; //swap the larger one among the left child and right child with index if(leftC &lt; length &amp;&amp; arr[leftC] &gt; arr[maxIndex]){ maxIndex = leftC; } if(rightC &lt; length &amp;&amp; arr[rightC] &gt; arr[maxIndex]){ maxIndex = rightC; } //when maxIndex is not equal to index, swap them if( maxIndex != index){ int temp = arr[maxIndex]; arr[maxIndex]= arr[index]; arr[index] = temp; //deal with the left or right child recursively heapSortOfIndexNode(arr,maxIndex,length); } } After the code above, it has become a max-heap for the index node and its child nodes. What we should do next is to go over all of the non-leaf nodes. bash123456789//go over all of the nodes private void heapSort(int[] arr,int length){ for(int index = (length -1) / 2 ; index &gt;= 0 ; index --){ heapSortOfIndexNode(arr,index,length); } } Until now, we have built a max-heap. The max value is located in arr[0]. If we swap the last value of the arr with arr[0], and the deal with the first n-1 elements of the array and so on so forth, we finally get the sorted array. codes as following: bash12345678910111213141516171819public void test() throws Exception{ int[] arr = {16,7,3,20,17,8}; for(int length = arr.length;length&gt;0;length--){ heapSort(arr,length); //swap arr[0] and the last element int temp = arr[0]; arr[0] = arr[length -1]; arr[length -1] = temp; } for(int i = 0;i&lt;arr.length;i++){ System.out.println(arr[i]); }} The outputs as follows: bash123456378161720 The above is the principle and code of the Heap Sorting. Using the heap, we can develop a general data structure, such as Priority Queue. Referencehttps://en.wikipedia.org/wiki/Heapsort","link":"/2021/02/02/my-first-blog-0/"}],"tags":[{"name":"priority queue","slug":"priority-queue","link":"/tags/priority-queue/"},{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"Numpy, Meshgrid","slug":"Numpy-Meshgrid","link":"/tags/Numpy-Meshgrid/"},{"name":"Heap","slug":"Heap","link":"/tags/Heap/"}],"categories":[]}